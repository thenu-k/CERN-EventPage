import { chunk } from "./core";
import { shallowEqual } from "../utils";
export function computed(dependencies, computeFn) {
    const dependencyValues = dependencies.map(dep => dep.get());
    let cachedValue = computeFn(...dependencyValues);
    const computedChunk = chunk(cachedValue);
    const originalSet = computedChunk.set;
    let isDirty = false;
    // Direct synchronous recomputation
    const recompute = () => {
        let hasChanges = false;
        for (let i = 0; i < dependencies.length; i++) {
            const newValue = dependencies[i].get();
            if (newValue !== dependencyValues[i]) {
                dependencyValues[i] = newValue;
                hasChanges = true;
            }
        }
        if (hasChanges) {
            const newValue = computeFn(...dependencyValues);
            // Fast path for primitives only. Avoids shallowEqual for performance.
            if (newValue !== cachedValue) {
                // Only use shallowEqual for objects when needed
                if (typeof newValue !== 'object' || typeof cachedValue !== 'object' || !shallowEqual(newValue, cachedValue)) {
                    cachedValue = newValue;
                    originalSet(newValue);
                }
            }
            isDirty = false;
        }
    };
    const unsubs = dependencies.map(dep => dep.subscribe(() => {
        isDirty = true;
        recompute();
    }));
    return {
        ...computedChunk,
        get: () => {
            if (isDirty)
                recompute();
            return cachedValue;
        },
        recompute,
        isDirty: () => isDirty,
        set: () => { throw new Error('Cannot set values directly on computed. Modify the source chunk instead.'); },
        reset: () => {
            dependencies.forEach(dep => {
                if (typeof dep.reset === 'function') {
                    dep.reset();
                }
            });
            isDirty = true;
            recompute();
            return cachedValue;
        },
        destroy: () => { unsubs.forEach(unsub => unsub()); computedChunk.destroy?.(); }
    };
}
