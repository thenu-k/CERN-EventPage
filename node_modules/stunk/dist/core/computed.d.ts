import { Chunk } from "./core";
export type ChunkValue<T> = T extends Chunk<infer U> ? U : never;
export type DependencyValues<T extends Chunk<any>[]> = {
    [K in keyof T]: T[K] extends Chunk<any> ? ChunkValue<T[K]> : never;
};
export interface Computed<T> extends Chunk<T> {
    /**
    * Checks if the computed value needs to be recalculated due to dependency changes.
    * @returns True if the computed value is dirty, false otherwise.
    */
    isDirty: () => boolean;
    /** Manually forces recalculation of the computed value from its dependencies. */
    recompute: () => void;
}
export declare function computed<TDeps extends Chunk<any>[], TResult>(dependencies: [...TDeps], computeFn: (...args: DependencyValues<TDeps>) => TResult): Computed<TResult>;
