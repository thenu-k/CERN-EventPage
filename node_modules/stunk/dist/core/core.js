import { processMiddleware } from "../utils";
let isBatching = false;
const dirtyChunks = new Set();
const chunkRegistry = new Map();
let chunkIdCounter = 0;
/**
 * Batch multiple chunk updates into a single re-render.
 * Useful for updating multiple chunks at once without causing multiple re-renders.
 */
export function batch(callback) {
    const wasBatchingBefore = isBatching;
    isBatching = true;
    try {
        callback();
    }
    finally {
        if (!wasBatchingBefore) {
            isBatching = false;
            const chunks = Array.from(dirtyChunks); // Snapshot to avoid mutation issues
            dirtyChunks.clear(); // Clear early to prevent re-adds
            chunks.forEach(id => {
                const chunk = chunkRegistry.get(id);
                if (chunk)
                    chunk.notify();
            });
        }
    }
}
export function chunk(initialValue, middleware = []) {
    if (initialValue === undefined || initialValue === null) {
        throw new Error("Initial value cannot be undefined or null.");
    }
    let value = initialValue;
    const subscribers = new Set();
    const chunkId = chunkIdCounter++;
    const notify = () => {
        subscribers.forEach(subscriber => subscriber(value));
    };
    chunkRegistry.set(chunkId, { notify });
    const notifySubscribers = () => {
        if (subscribers.size === 0)
            return; // Skip if no subscribers
        if (isBatching) {
            dirtyChunks.add(chunkId);
        }
        else {
            notify();
        }
    };
    const get = () => value;
    const set = (newValueOrUpdater) => {
        let newValue;
        if (typeof newValueOrUpdater === 'function') {
            newValue = newValueOrUpdater(value);
        }
        else {
            newValue = newValueOrUpdater;
        }
        const processedValue = processMiddleware(newValue, middleware);
        if (processedValue !== value) {
            value = processedValue;
            notifySubscribers();
        }
    };
    const subscribe = (callback) => {
        if (typeof callback !== "function") {
            throw new Error("Callback must be a function.");
        }
        subscribers.add(callback);
        callback(value);
        return () => subscribers.delete(callback);
    };
    const reset = () => {
        value = initialValue;
        notifySubscribers();
    };
    const destroy = () => {
        subscribers.clear();
        value = initialValue;
        dirtyChunks.delete(chunkId);
        chunkRegistry.delete(chunkId);
    };
    const derive = (fn) => {
        if (typeof fn !== "function") {
            throw new Error("Derive function must be a function.");
        }
        const initialDerivedValue = fn(value);
        const derivedChunk = chunk(initialDerivedValue);
        const unsubscribe = subscribe(() => {
            const newDerivedValue = fn(value);
            derivedChunk.set(newDerivedValue);
        });
        // Add a cleanup method to the derived chunk
        const originalDestroy = derivedChunk.destroy;
        derivedChunk.destroy = () => {
            unsubscribe();
            originalDestroy();
        };
        return derivedChunk;
    };
    return { get, set, subscribe, derive, reset, destroy };
}
